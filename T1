import numpy as np

# data
X1 = np.array([1, 2, 3, 3, 2], dtype=float)
X2 = np.array([1, 1, 2, 5, 4], dtype=float)
y  = np.array([0, 0, 0, 1, 1], dtype=float)

m = len(y)
alpha = 0.01

# initial weights
w0 = 0.5
w1 = 0.5
w2 = 0.5

def sigmoid(z):
    return 1 / (1 + np.exp(-z))

def cost(w0, w1, w2):
    z = w0 + w1 * X1 + w2 * X2
    h = sigmoid(z)
    eps = 1e-15  # to avoid log(0)
    J = -np.mean(y * np.log(h + eps) + (1 - y) * np.log(1 - h + eps))
    return J

def gradients(w0, w1, w2):
    z = w0 + w1 * X1 + w2 * X2
    h = sigmoid(z)
    err = h - y
    dw0 = np.mean(err)
    dw1 = np.mean(err * X1)
    dw2 = np.mean(err * X2)
    return dw0, dw1, dw2

print("Initial:")
print("w0,w1,w2 =", w0, w1, w2)
print("J0 =", cost(w0, w1, w2))

for step in range(1, 3):  # 2 updates
    dw0, dw1, dw2 = gradients(w0, w1, w2)
    w0 -= alpha * dw0
    w1 -= alpha * dw1
    w2 -= alpha * dw2
    print(f"\nAfter update {step}:")
    print("dw0,dw1,dw2 =", dw0, dw1, dw2)
    print("w0,w1,w2 =", w0, w1, w2)
    print(f"J{step} =", cost(w0, w1, w2))
